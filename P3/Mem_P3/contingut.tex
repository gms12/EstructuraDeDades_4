\chapter{Comentaris de la pràctica}

\section{Exercici 1 - Arbre binari de cerca}
\subsection{Observacions i decisions preses}
En aquest exercici hem decidit no fer un menú i testejar els mètodes un a un de manera consecutiva, amb un arbre arbitrari. No obstant, aquest procediment l'hem dut a terme per més d'un arbre, per assegurar-nos que tots els mètodes funcionaven correctament.
\subsection{Qüestions}
\begin{itemize}
	\item \textbf{Justifiqueu el cost computacional teòric de les funcions del TAD \cl{BinarySearchTree} i del TAD \cl{NodeTree}. Si implementeu altres mètodes necessaris pel desenvolupament de la pràctica, justifiqueu-ne el seu ús i el seu cost computacional teòric.}
	\newline
	Els mètodes auxiliars que hem afegit els utilitzem per implementar el mètode de manera recursiva. Per exemple en el mètode \met{insert}, tenim un mètode auxiliar que rep com a paràmetre un node. Aleshores comprova si el nou node hauria d'anar a l'esquerra o a la dreta i torna a cridar el mètode per al node fill que correspongui.
	\begin{itemize}
	\item \textbf{Constructors:}
				\begin{itemize}
					\item \underline{\met{BinarySearchTree}():} Només assigna valors, així que té cost constant, O(1).
					\item \underline{\met{BinarySearchTree}(const \cl{BinarySearchTree}\& orig):} El seu cost és el mateix del seu mètode auxiliar \met{constructor\_copia}, ja que simplement crida aquest mètode.
				\end{itemize}
	\item \textbf{Destructor:}
				\begin{itemize}
					\item \underline{\primary{virtual} \met{$\sim$ BinarySearchTree}():} El seu cost és el mateix del seu mètode auxiliar \met{postDelete}, ja que simplement crida aquest mètode.
				\end{itemize}
	\item \textbf{Consultors:}
				\begin{itemize}
					\item \underline{\primary{int} \met{size}():} El seu cost és el mateix del seu mètode auxiliar \met{size}, ja que simplement crida aquest mètode.
					\item \underline{\primary{bool} \met{isEmpty}():} Només comprova si \cl{pRoot} és nul, per tant té cost constant, O(1).
					\item \underline{\cl{NodeTree\textless Type\textgreater }* \met{root}():} Simplement retorna el node arrel, així que té cost constant, O(1).
					\item \underline{\primary{bool} \met{search}(const \cl{Type}\& element):} El seu cost és el mateix del seu mètode auxiliar \met{search}, ja que simplement crida aquest mètode.
					\item \underline{\primary{void} \met{printInorder}() const:} El seu cost és el mateix del seu mètode auxiliar \met{printInorder}, ja que simplement crida aquest mètode.
					\item \underline{\primary{void} \met{printPreorder}() const:} El seu cost és el mateix del seu mètode auxiliar \met{printPreorder}, ja que simplement crida aquest mètode.
					\item \underline{\primary{void} \met{printPostorder}() const:} El seu cost és el mateix del seu mètode auxiliar \met{printPostorder}, ja que simplement crida aquest mètode.
					\item \underline{\primary{int} \met{getHeight}():} El seu cost és el mateix del seu mètode auxiliar \met{getHeight}, ja que simplement crida aquest mètode.
				\end{itemize}
	\item \textbf{Modificadors:}
				\begin{itemize}
					\item \underline{\primary{void} \met{insert}(const \cl{Type}\& element):} El seu cost és el mateix del seu mètode auxiliar \met{insert}, ja que simplement crida aquest mètode.
				\end{itemize}
	\item \textbf{Mirall:}
				\begin{itemize}
					\item \underline{\cl{BinarySearchTree\textless Type\textgreater }* \met{mirror}():} El seu cost és el mateix del seu mètode auxiliar \met{constructor\_mirall}, ja que simplement crida aquest mètode.
				\end{itemize}
	\item \textbf{Mètodes privats interns. Són mètodes auxiliars:}
				\begin{itemize}
					\item \underline{\primary{void} \met{postDelete}(\cl{NodeTree\textless Type\textgreater }* p):} Mètode recursiu que recorre l'arbre en post ordre i n'elimina els nodes. Com que recorre tots els nodes el seu cost és O(n).
					\item \underline{\primary{int} \met{size}(\cl{NodeTree\textless Type\textgreater }* p) const:} Com abans, es recorren tots els nodes. Cost O(n).
					\item \underline{\primary{void} \met{printPreorder}(\cl{NodeTree\textless Type\textgreater }* p) const:} Mateix cas, O(n).
					\item \underline{\primary{void} \met{printPostorder}(\cl{NodeTree\textless Type\textgreater }* p) const:} Mateix cas, O(n).
					\item \underline{\primary{void} \met{printInorder}(\cl{NodeTree\textless Type\textgreater }* p) const:} Mateix cas, O(n).
					\item \underline{\primary{int} \met{getHeight}(\cl{NodeTree\textless Type\textgreater }* p):} Mateix cas, O(n).
					
					\item \underline{\primary{void} \met{insert}(\cl{NodeTree\textless Type\textgreater }* p, const \cl{Type}\& element):} Mètode recursiu auxiliar per a insertar un node. En general recorrerà un nombre de nodes igual a l'alçada (log n), però pot ser que els hagi de recorrer tots, per tal com està construit l'arbre binari. Per tant el cost és O(n).
					\item \underline{\cl{NodeTree\textless Type\textgreater }* \met{search}(\cl{NodeTree\textless Type\textgreater }* p, const \cl{Type}\& element):} Mateix cas que abans. Cost O(n).
					\item \underline{\cl{NodeTree\textless Type\textgreater }* \met{constructor\_copia}(\cl{NodeTree\textless Type\textgreater }* from):} Mètode recursiu auxiliar per al constructor còpia. Recorre tot els nodes de l'arbre del qual es vol fer la copia, així que té cost lineal O(n).
					\item \underline{\cl{NodeTree\textless Type\textgreater }* \met{constructor\_mirall}(\cl{NodeTree\textless Type\textgreater }* from):} Similar al d'abans. Cost O(n).
				\end{itemize}
	\end{itemize}        
\end{itemize}

\section{Exercici 2 - Cercador de pel·lícules amb arbres de cerca binària}
\subsection{Observacions i decisions preses}
Per a dur a terme aquesta part de l'entrega hem agafat les classes programades a l'exercici 1 i hem afegit les classes \cl{Movie} i \cl{BSTMovieFinder}. La segona contindrà l'arbre binari, format per nodes amb pel·lícules. Hem adaptat les classes \cl{BinarySearchTree} per tal que disposin d'una clau i fer més simple l'ús de la classe \cl{Movie}.
Per a realitzar la funció de lectura de fitxers, com que cada 40 elements volem preguntar a l'usuari si segueix interessat en llegir-ne més, hem afegit un comptador a la classe \cl{BinarySearchTree} que es va actualitzant cada vegada que s'imprimeix un element, és a dir, que també hem modificat lleugerament el mètode \met{printInorder}.

\section{Exercici 3 - Arbres binaris balancejats}
\subsection{Observacions i decisions preses}
Respecte els exercicis anteriors essencialment hem canviat tan sols el mètode \met{insert} i n'hem afegit de complementaris per a realitzar les rotacions. Inicialment hem seguit l'estructura utilitzada anteriorment, però degut a que obteniem errors hem decidit canviar el mètode i fer que aquesta vegada retornès un node, modificant lleugerament com estava plantejat el mètode \met{insert} original.
\newline
Respecte les funcions de saber el títol més llarg i la puntuació més baixa [alta] i les pel·lícules amb aquesta puntuació, hem modificat el mètode \met{toString} de \cl{Movie} perquè retornés el títol i la puntuació en un mateix \primary{string}. D'aquesta manera, com que la puntuació té sempre la mateixa longitud, no influia en saber el títol més llarg. Pel que fa a les puntuacions, primer hem fet mètodes per buscar recursivament dins l'arbre la millor [pitjor] puntuació, i un cop la teniem hem creat un mètode recursiu que imprimia per pantalla les pel·lícules amb aquella mateixa puntuació.
\newline
L'alternativa a aquesta implementació era deixar d'implementar el TAD amb template, cosa que ens ha semblat innecessari i no gaire estètic, ja que volíem que els nostres TAD's tinguessin la major generalitat possible i es poguéssin utilitzar amb classes diferents.
\subsection{Qüestions}
\begin{itemize}
	\item \textbf{Expliqueu les similituds i diferències en la implementació d'aquest TAD \cl{BalancedBST} respecte al TAD \cl{BinarySearchTree}. Detalleu quin és el cost computacional teòric de cadascuna de les operacions del TAD.}
	\newline
	El funcionament del TAD és exactament el mateix, només canvia el mètode \met{insert}. En aquest, un cop afegit el nou node, fem comprovacions per a veure si l'arbre està balancejat, i en cas negatiu realitzem les rotacions pertinents. D'aquesta manera ens assegurem que l'alçada de l'arbre sigui sempre $\log n$, on $n$ és el nombre de nodes de l'arbre.
	\newline
Per tant, els mètodes \met{insert} i \met{search} tindran ara un cost O($\log n$), inferior al lineal.
\newline
Per altra banda, els mètodes de les rotacions tenen un cost constant, ja que simplement reassignen punters.
\newline
Finalment, els mètodes afegits per a obtenir el títol de pel·lícula més llarg i les millors i pitjors puntuacions (amb les pel·lícules corresponents), donat que recorren l'arbre sencer, tindran un cost lineal O(n).
	\end{itemize}

\section{Exercici 4 - Cercador de pel·lícules amb arbres binaris balancejats}
\subsection{Observacions i decisions preses}
Per aquest exercici hem agafat el número dos i hem canviat la classe \cl{BinarySearchTree} per la \cl{BalancedBST}. Com es tracten d'arbres amb les mateixes funcionalitats no hem hagut de canviar res més, tan sols la classe de l'atribut arbre de la classe \cl{BSTMovieFinder}, la resta és totalment compatible.
\section{Exercici 5 - Avaluació de les estructures}
\subsection{Observacions i decisions preses}
En aquest exercici hem decidit no fer un menú, ja que volíem que el test el fes l'ordinador tot sol. És per això que es fan els tests en sèrie, és a dir, primer amb el fitxer petit i després amb el gran. Hem modificat el fitxer de cerca per que sigui més gran i augmentar el temps per veure diferències; tot i això no n'hem pogut trobar (com expliquem més endavant).
\subsection{Qüestions}
\begin{itemize}
	\item \textbf{Raoneu els resultats de temps obtinguts en la comparació dels TADs \cl{BSTMovieFinder} i \cl{BalancedBSTMovieFinder}.}
	\newline
Pel fitxer petit no es poden apreciar diferències en cap de les accions (creació o cerca). Les creacions (procés de llegir el fitxer) són molt ràpides, menys d'un mil·lisegon, ja que no s'aprecia diferència entre el temps inicial i el final. Malgrat els dos arbres tenir 100 elements, el binari té una alçada de 13, mentre que el balancejat en té 8 només (recordem que serà aproximadament $\lceil\log_{2}{n}\rceil+1$). La busca tampoc té diferències significatives.
\newline
En canvi, quan fem la prova al fitxer gran, hi ha una diferència molt gran a l'hora de construir els arbres. L'arbre binari ho fa molt de pressa, però el balancejat triga molt més, ja que ha de rotar alguns nodes en algunes ocasions, i això, malgrat ser només reassignacions de punters, el fa endarrerir molt. Recordem que fer una rotació és un cost lineal, però ho fa entre 0 i dues vegades per node, de mitjana unes 10000 vegades.
\newline
Analitzant la cerca veiem que tampoc hi ha una diferència apreciable de temps. Suposem que per a un nombre de dades més elevat es notaria molt més (l'arbre binari té 31 nivells i el balancejat 16, diferència gairebé inapreciable al fer una cerca amb un processador decent).
	\item \textbf{Indiqueu quin és el cost computacional teòric de les operacions d'inserció i cerca en els dos arbres implementats (exercici 1 i exercici 3).}
	\newline
El cost computacional teòric per a la inserció de l'exercici 1 és logarítmic de mitjana, però el pitjor dels casos és lineal, O(n). La cerca és el mateix, ja que la inserció és una cerca i assignacions a un node.
	\newline
En el cas de l'exercici 3, al ser balancejat el cost teòric mitjà i el pitjor coincideix, i és O($\log n$). La cerca té el mateix cost, ja que una inserció consta d'una cerca i assignacions de punters (aquí en poden ser més, d'assignacions, ja que es poden fer rotacions dels nodes. Malgrat això, al tenir un cost lineal no alteren el comportament logarítmic de l'algorisme).
\end{itemize}